use actix_web::{get, middleware::Logger, web, App, HttpResponse, HttpServer, Responder, ResponseError};
use azure_core::credentials::TokenCredential; 
use azure_identity::{WorkloadIdentityCredential, WorkloadIdentityCredentialOptions};
use moka::future::Cache;
use rand::Rng;
use serde::{Deserialize, Serialize};
use std::{
    env,
    sync::Arc,
    time::Duration,
    error::Error,
};
use thiserror::Error;
use tokio_retry::strategy::ExponentialBackoff;
use tokio_retry::Retry;
use time::{OffsetDateTime, Duration as TimeDuration};
use log::{info, error};
use tokio::sync::RwLock;

// ----------------------
// Configuration Utilities
// ----------------------
fn get_env_required(key: &str) -> Result<String, Box<dyn Error>> {
    env::var(key).map_err(|_| format!("Required environment variable '{}' not set.", key).into())
}

fn get_env_default<T: std::str::FromStr>(key: &str, default: T) -> T {
    env::var(key)
        .ok()
        .and_then(|v| v.parse().ok())
        .unwrap_or(default)
}

#[derive(Clone)]
struct Config {
    subscription_id: String,
    show_preview: bool,
    port: u16,
    cache_ttl_seconds: u64,
}

impl Config {
    fn from_env() -> Result<Self, Box<dyn Error>> {
        Ok(Self {
            subscription_id: get_env_required("AZ_SUBSCRIPTION_ID")?, 
            show_preview: get_env_default("SHOW_PREVIEW", false),
            port: get_env_default("HTTP_PORT", 8080),
            cache_ttl_seconds: get_env_default("CACHE_TTL_SECONDS", 3600),
        })
    }
}

// ----------------------
// Data Models 
// ----------------------
#[derive(Debug, Deserialize, Clone)]
struct OrchestratorsResponse {
    properties: OrchestratorsProperties,
}

#[derive(Debug, Deserialize, Clone)]
struct OrchestratorsProperties {
    orchestrators: Vec<OrchestratorItem>,
}

#[derive(Debug, Deserialize, Clone)]
struct OrchestratorItem {
    #[serde(rename = "orchestratorType")]
    orchestrator_type: String,
    #[serde(rename = "orchestratorVersion")]
    orchestrator_version: String,
    #[serde(default)]
    is_preview: bool,
}

#[derive(Debug, Serialize, Clone, PartialEq, Eq, PartialOrd, Ord)]
struct Orchestrator {
    orchestrator_version: String,
    is_preview: bool,
}

// ----------------------
// App State
// ----------------------
struct AppState {
    show_preview: bool,
    cache: Cache<String, Vec<Orchestrator>>,
    token_cache: Arc<RwLock<CachedToken>>,
    credential: Arc<WorkloadIdentityCredential>, // Expected type: Arc<T>
    http_client: reqwest::Client,
    config: Config,
}

// ----------------------
// Token Cache
// ----------------------
#[derive(Debug, Default)]
struct CachedToken {
    token: Option<String>,
    expires_at: Option<OffsetDateTime>,
}

impl CachedToken {
    fn is_valid(&self) -> bool {
        if let Some(exp) = self.expires_at {
            exp > OffsetDateTime::now_utc() + TimeDuration::seconds(30) 
        } else {
            false
        }
    }
}

// ----------------------
// Errors
// ----------------------
#[derive(Debug, Error, Clone)]
enum AksError {
    #[error("Azure error: {0}")]
    AzureError(String),
    #[error("Failed to parse Azure response")]
    ParseError,
    #[error("Invalid location parameter")]
    ValidationError,
}

impl ResponseError for AksError {
    fn error_response(&self) -> HttpResponse {
        let status = match self {
            AksError::ValidationError => actix_web::http::StatusCode::BAD_REQUEST,
            _ => actix_web::http::StatusCode::INTERNAL_SERVER_ERROR,
        };
        HttpResponse::build(status).json(serde_json::json!({ "error": self.to_string() }))
    }
}

// ----------------------
// Helpers
// ----------------------
async fn get_token(
    credential: &Arc<WorkloadIdentityCredential>, 
    cache: &Arc<RwLock<CachedToken>>,            
) -> Result<String, AksError> {
    
    {
        let read_guard = cache.read().await;
        if read_guard.is_valid() {
            if let Some(token) = &read_guard.token {
                return Ok(token.clone());
            }
        }
    }

    let token_response = credential
        .get_token(&["https://management.azure.com/.default"], None)
        .await
        .map_err(|e| AksError::AzureError(format!("Failed to get token: {e}")))?;

    let token_string = token_response.token.secret().to_string();
    let expires_in: OffsetDateTime = token_response.expires_on;

    let mut write_guard = cache.write().await;
    write_guard.token = Some(token_string.clone());
    write_guard.expires_at = Some(expires_in);

    info!("Azure token refreshed, expires at {:?}", expires_in);

    Ok(token_string)
}

async fn fetch_aks_versions(
    client: &reqwest::Client,
    subscription_id: &str, 
    location: &str,       
    token: String,
) -> Result<Vec<Orchestrator>, AksError> {
    let api_version = "2020-11-01";
    let url = format!(
        "https://management.azure.com/subscriptions/{}/providers/Microsoft.ContainerService/locations/{}/orchestrators?api-version={}",
        subscription_id, location, api_version
    );

    let resp = client
        .get(&url)
        .bearer_auth(token)
        .send()
        .await
        .map_err(|e| AksError::AzureError(format!("Request failed: {e}")))?;

    if !resp.status().is_success() {
        let status = resp.status();
        let body = resp.text().await.unwrap_or_else(|_| "No response body".to_string());
        error!("Azure API request failed with status: {}. Response: {}", status, body);
        return Err(AksError::AzureError(format!("API call failed with status {}", status)));
    }

    let resp_json: OrchestratorsResponse = resp.json().await.map_err(|_| AksError::ParseError)?;

    let orchestrators = resp_json
        .properties
        .orchestrators
        .into_iter()
        .filter(|o| o.orchestrator_type == "Kubernetes")
        .map(|o| Orchestrator {
            orchestrator_version: o.orchestrator_version,
            is_preview: o.is_preview,
        })
        .collect();

    Ok(orchestrators)
}

async fn fetch_with_retry(
    client: reqwest::Client,
    subscription_id: String,
    location: String,
    token: String,
) -> Result<Vec<Orchestrator>, AksError> {
    
    let strategy = ExponentialBackoff::from_millis(50).take(5).map(move |d| {
        let mut rng = rand::rng();
        let jitter = rng.random_range(0..30); 
        d + Duration::from_millis(jitter as u64)
    });
    
    Retry::spawn(strategy, move || {
        
        let client_clone = client.clone();
        let sub_id_clone = subscription_id.clone();
        let loc_clone = location.clone();
        let token_clone = token.clone();

        async move {
            fetch_aks_versions(
                &client_clone,
                &sub_id_clone,
                &loc_clone,
                token_clone 
            ).await
        }
    })
    .await
}

// ----------------------
// HTTP Handlers
// ----------------------
#[derive(Debug, Deserialize)]
struct LocationQuery {
    location: String,
}

#[get("/")]
async fn aks_versions(
    query: web::Query<LocationQuery>,
    data: web::Data<AppState>,
) -> Result<impl Responder, AksError> {
    let location_key = query.location.trim().to_string();
    if location_key.is_empty() {
        return Err(AksError::ValidationError);
    }

    let token = get_token(&data.credential, &data.token_cache).await?;

    let client = data.http_client.clone();
    let sub_id = data.config.subscription_id.clone();
    
    let list = data
        .cache
        .try_get_with(location_key.clone(), async move {
            fetch_with_retry(client, sub_id, location_key, token).await
        })
        .await
        .map_err(|e| (*e).clone())?; 

    let mut versions: Vec<String> = list
        .into_iter()
        .filter(|o| data.show_preview || !o.is_preview)
        .map(|o| o.orchestrator_version)
        .collect();

    versions.sort_unstable(); 

    Ok(HttpResponse::Ok().json(serde_json::json!({ "versions": versions })))
}

#[get("/healthz")]
async fn healthz(data: web::Data<AppState>) -> impl Responder {
    HttpResponse::Ok().json(serde_json::json!({
        "status": "ok",
        "cache_items": data.cache.entry_count()
    }))
}

// ----------------------
// Main Server
// ----------------------
#[actix_web::main]
async fn main() -> Result<(), Box<dyn Error>> { 
    // Initialize logging
    env_logger::init_from_env(env_logger::Env::new().default_filter_or("info"));
    
    let config = match Config::from_env() {
        Ok(c) => c,
        Err(e) => {
            error!("Configuration Error: {}", e);
            return Err(e);
        }
    };

    let cache = Cache::builder()
        .time_to_live(Duration::from_secs(config.cache_ttl_seconds))
        .max_capacity(100)
        .build();

    let token_cache = Arc::new(RwLock::new(CachedToken::default())); 
    
    let http_client = reqwest::Client::new();

    let app_state = web::Data::new(AppState {
        show_preview: config.show_preview,
        cache,
        token_cache,
        // FIX: The WorkloadIdentityCredential::new() already returns Arc<T> in your environment, 
        // so we remove the surrounding Arc::new() call. The ? unwraps the Result, leaving Arc<T>.
        credential: WorkloadIdentityCredential::new(Some(WorkloadIdentityCredentialOptions::default()))
            .map_err(|e| format!("Failed to create WorkloadIdentityCredential: {}", e))?, 
        http_client,
        config: config.clone(),
    });

    info!("Server starting on http://0.0.0.0:{}", config.port);

    HttpServer::new(move || {
        App::new()
            .app_data(app_state.clone())
            .wrap(Logger::default())
            .service(aks_versions)
            .service(healthz)
    })
    .bind(("0.0.0.0", config.port))?
    .run()
    .await?;

    Ok(())
}
