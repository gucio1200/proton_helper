use actix_web::{get, middleware::Logger, web, App, HttpResponse, HttpServer, Responder, ResponseError};
use azure_core::credentials::TokenCredential;
use azure_identity::{WorkloadIdentityCredential, WorkloadIdentityCredentialOptions};
use moka::future::Cache;
use rand::Rng;
use serde::{Deserialize, Serialize};
use std::{
    env,
    sync::{Arc, RwLock},
    time::Duration,
};
use thiserror::Error;
use tokio_retry::strategy::ExponentialBackoff;
use tokio_retry::Retry;
use time::{OffsetDateTime, Duration as TimeDuration};

// ----------------------
// Config
// ----------------------
fn env_var_or_default<T: std::str::FromStr>(key: &str, default: T) -> T {
    env::var(key)
        .ok()
        .and_then(|v| v.parse().ok())
        .unwrap_or(default)
}

#[derive(Clone)]
struct Config {
    subscription_id: String,
    show_preview: bool,
    port: u16,
    cache_ttl_seconds: u64,
}

impl Config {
    fn from_env() -> Self {
        Self {
            subscription_id: env_var_or_default("AZ_SUBSCRIPTION_ID", "".to_string()),
            show_preview: env_var_or_default("SHOW_PREVIEW", false),
            port: env_var_or_default("HTTP_PORT", 8080),
            cache_ttl_seconds: env_var_or_default("CACHE_TTL_SECONDS", 3600),
        }
    }
}

// ----------------------
// Data Models
// ----------------------
#[derive(Debug, Deserialize, Clone)]
struct OrchestratorsResponse {
    properties: OrchestratorsProperties,
}

#[derive(Debug, Deserialize, Clone)]
struct OrchestratorsProperties {
    orchestrators: Vec<OrchestratorItem>,
}

#[derive(Debug, Deserialize, Clone)]
struct OrchestratorItem {
    #[serde(rename = "orchestratorType")]
    orchestrator_type: String,
    #[serde(rename = "orchestratorVersion")]
    orchestrator_version: String,
    #[serde(default)]
    is_preview: bool,
}

#[derive(Debug, Serialize, Clone)]
struct Orchestrator {
    orchestrator_version: String,
    is_preview: bool,
}

// ----------------------
// App State
// ----------------------
struct AppState {
    show_preview: bool,
    cache: Cache<String, Vec<Orchestrator>>,
    token_cache: Arc<RwLock<CachedToken>>,
    credential: Arc<WorkloadIdentityCredential>,
    http_client: reqwest::Client,
    config: Config,
}

// ----------------------
// Token Cache
// ----------------------
#[derive(Debug, Default)]
struct CachedToken {
    token: Option<String>,
    expires_at: Option<OffsetDateTime>,
}

impl CachedToken {
    fn is_valid(&self) -> bool {
        if let Some(exp) = self.expires_at {
            exp > OffsetDateTime::now_utc() + TimeDuration::seconds(30) 
        } else {
            false
        }
    }
}

// ----------------------
// Errors
// ----------------------
#[derive(Debug, Error, Clone)]
enum AksError {
    #[error("Azure error: {0}")]
    AzureError(String),
    #[error("Failed to parse Azure response")]
    ParseError,
    #[error("Invalid location parameter")]
    ValidationError,
}

impl ResponseError for AksError {
    fn error_response(&self) -> HttpResponse {
        let status = match self {
            AksError::ValidationError => actix_web::http::StatusCode::BAD_REQUEST,
            _ => actix_web::http::StatusCode::INTERNAL_SERVER_ERROR,
        };
        HttpResponse::build(status).json(serde_json::json!({ "error": self.to_string() }))
    }
}

// ----------------------
// Helpers
// ----------------------
async fn get_token(
    credential: &Arc<WorkloadIdentityCredential>,
    cache: &Arc<RwLock<CachedToken>>,
) -> Result<String, AksError> {
    {
        let read_guard = cache.read().unwrap();
        if read_guard.is_valid() {
            if let Some(token) = &read_guard.token {
                return Ok(token.clone());
            }
        }
    }

    let token_response = credential
        .get_token(&["https://management.azure.com/.default"], None)
        .await
        .map_err(|e| AksError::AzureError(format!("Failed to get token: {e}")))?;

    let token_string = token_response.token.secret().to_string();
    let expires_in: OffsetDateTime = token_response.expires_on;

    let mut write_guard = cache.write().unwrap();
    write_guard.token = Some(token_string.clone());
    write_guard.expires_at = Some(expires_in);

    println!("Azure token refreshed, expires at {:?}", expires_in);

    Ok(token_string)
}

// Takes &reqwest::Client for API calls
async fn fetch_aks_versions(
    client: &reqwest::Client,
    subscription_id: String,
    location: String,
    token: String,
) -> Result<Vec<Orchestrator>, AksError> {
    let api_version = "2020-11-01";
    let url = format!(
        "https://management.azure.com/subscriptions/{}/providers/Microsoft.ContainerService/locations/{}/orchestrators?api-version={}",
        subscription_id, location, api_version
    );

    let resp = client
        .get(&url)
        .bearer_auth(token)
        .send()
        .await
        .map_err(|e| AksError::AzureError(format!("Request failed: {e}")))?;

    let resp_json: OrchestratorsResponse = resp.json().await.map_err(|_| AksError::ParseError)?;

    let orchestrators = resp_json
        .properties
        .orchestrators
        .into_iter()
        .filter(|o| o.orchestrator_type == "Kubernetes")
        .map(|o| Orchestrator {
            orchestrator_version: o.orchestrator_version,
            is_preview: o.is_preview,
        })
        .collect();

    Ok(orchestrators)
}

// Takes owned reqwest::Client (a clone)
async fn fetch_with_retry(
    client: reqwest::Client,
    subscription_id: String,
    location: String,
    token: String,
) -> Result<Vec<Orchestrator>, AksError> {
    
    let strategy = ExponentialBackoff::from_millis(50).take(5).map(move |d| {
        let mut rng = rand::rng();
        let jitter = rng.random_range(0..30); 
        d + Duration::from_millis(jitter as u64)
    });

    let sub_id = subscription_id.clone();
    let loc = location.clone();
    let client_cloned = client.clone();
    let token_cloned = token.clone();
    Retry::spawn(strategy, move || {
        
        let client_for_future = client_cloned.clone();
        let sub_id_for_future = sub_id.clone();
        let loc_for_future = loc.clone();
        let token_for_future = token_cloned.clone();        
        async move {
            fetch_aks_versions(&client_for_future, sub_id_for_future, loc_for_future, token_for_future).await
        }
    })
    .await
}

// ----------------------
// HTTP Handlers
// ----------------------
#[derive(Debug, Deserialize)]
struct LocationQuery {
    location: String,
}

#[get("/")]
async fn aks_versions(
    query: web::Query<LocationQuery>,
    data: web::Data<AppState>,
) -> Result<impl Responder, AksError> {
    let location = query.location.trim().to_string();
    if location.is_empty() {
        return Err(AksError::ValidationError);
    }

    let token = get_token(&data.credential, &data.token_cache).await?;
    let client = data.http_client.clone();
    let sub_id = data.config.subscription_id.clone();
    let loc_key = location.clone();

    let list = data
        .cache
        .try_get_with(location, async move {
            fetch_with_retry(client, sub_id, loc_key, token).await
        })
        .await
        .map_err(|e| (*e).clone())?;

    let versions: Vec<String> = list
        .into_iter()
        .filter(|o| data.show_preview || !o.is_preview)
        .map(|o| o.orchestrator_version)
        .collect();

    Ok(HttpResponse::Ok().json(serde_json::json!({ "versions": versions })))
}

#[get("/healthz")]
async fn healthz(data: web::Data<AppState>) -> impl Responder {
    HttpResponse::Ok().json(serde_json::json!({
        "status": "ok",
        "cache_items": data.cache.entry_count()
    }))
}

// ----------------------
// Main Server
// ----------------------
#[actix_web::main]
async fn main() -> std::io::Result<()> {
    env_logger::init_from_env(env_logger::Env::new().default_filter_or("info"));
    let config = Config::from_env();
    let cache = Cache::builder()
        .time_to_live(Duration::from_secs(config.cache_ttl_seconds))
        .max_capacity(100)
        .build();
    let token_cache = Arc::new(RwLock::new(CachedToken::default()));    
    let credential = WorkloadIdentityCredential::new(Some(WorkloadIdentityCredentialOptions::default())).unwrap();    
    let http_client = reqwest::Client::new();
    let app_state = web::Data::new(AppState {
        show_preview: config.show_preview,
        cache,
        token_cache,
        credential, 
        http_client,
        config: config.clone(),
    });

    println!("Server starting on http://0.0.0.0:{}", config.port);

    HttpServer::new(move || {
        App::new()
            .app_data(app_state.clone())
            .wrap(Logger::default())
            .service(aks_versions)
            .service(healthz)
    })
    .bind(("0.0.0.0", config.port))?
    .run()
    .await
}
